---
{"dg-publish":true,"permalink":"/日常学习/技术学习/凤凰架构/透明多级分流系统/","noteIcon":"1","created":"2023-10-12T19:30:55.747+08:00","updated":"2023-10-12T19:57:54.401+08:00"}
---

# 基本原则

- 尽可能**减少单点部件**，如果无法避免则最大限度减少到达单点部件的流量，最典型的例子是位于请求调用链末端的传统关系型数据库。
- 奥卡姆剃刀原则，即**如无必要，勿增实体**。多级分流不是越多越好，高并发高可用不是每个系统都追求的，最简单的系统是最好的系统。

# 客户端缓存

## 状态缓存

不经过服务器，直接根据缓存信息对目标网站的状态判断，以前只有 301（永久重定向）一种，后来增加了 HSTS（HTTP Strict Transport Security）。

## 强制缓存

客户端无需经过任何请求，在条件满足期间一直持有和使用该资源的本地缓存副本，用户主动刷新时（F5）失效。

- Expires（HTTP/1.0）
  - 直接跟截止时间，直观易懂。
  - 受限于客户端本地时间，本地时间修改后可能会出现缓存提前失效或超期持有。
  - 无法处理涉及用户身份认证的私有资源。
  - 无法精准描述**不缓存**的语义，通常需要使用额外脚本或在资源后手动增加时间戳。
- Cache-Control（HTTP/1.1）
  - 和 Expires 语义冲突时以 Cache-Control 为准。
  - 定义了一系列标准参数，如 no-transform 禁止资源被任何形式地修改，设置后则禁止自动 GZip 压缩图片或文本提高网络性能。

# 协商缓存

强制缓存基于时效性，但往往无法判断资源保持不变的时长。协商缓存一致性表现更好，但需要一次变化检测的额外开销。二者不具备互斥性，可以并行存在。

- Last-Modified 和 If-Modified-Since：前者是服务器响应 Header，告知客户端资源最后修改时间，客户端下次请求会带上 If-Modified-Since，并由服务端判断这之后资源是否修改过。如未修改，则返回 304 响应，不携带消息体，节省流量，缺点是只能精确到秒级，以及无法促使内容不变但 Last-Modified 发生改变的资源有效使用缓存。
- Etag 和 If-None-Match：Etag 是资源唯一标识，一般根据文件索引节点、大小和修改时间经哈希计算获得。该机制是一致性最强的缓存机制，文件在一秒内被多次修改，或未修改但 Last-Modified 改变等情况也能正确反馈。但该机制需要单独哈希计算，因此也是性能最差的缓存机制。
  > [!cautious]+ 失效情况
  > 协商缓存在用户主动刷新（F5）时**依旧生效**，只有用户强制刷新（Ctrl+F5）或明确禁用缓存（DevTools）时才失效，此时客户端发请求会自动携带“Cache-Control: no-cache”。

# 域名解析
