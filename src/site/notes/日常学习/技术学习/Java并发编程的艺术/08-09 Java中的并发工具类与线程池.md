---
{"dg-publish":true,"permalink":"/日常学习/技术学习/Java并发编程的艺术/08-09 Java中的并发工具类与线程池/","title":"08-09 Java中的并发工具类与线程池","tags":["八股","Java并发"],"noteIcon":"1","created":"2023-07-27T10:13:20.657+08:00","updated":"2025-01-01T10:49:27.029+08:00"}
---


- CountDownLatch：允许一个或多个线程等待其他线程完成操作，可以实现 join 的功能，传入 int 类型参数作为计数器。
- CyclicBarrier：一组线程到达一个屏障/同步点时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被拦截的线程才会继续运行。
- Semaphore：控制并发线程数，即同时访问特定资源的线程数量。
- Exchanger：线程间数据交换。
- 线程池工作流程：
  - 如果线程数少于基本线程数，则创建线程并执行任务。
  - 如果运行线程大于等于基本线程数，或线程创建失败，则把当前任务放入工作队列。
  - 如果无法将任务加入工作队列（即队列已满），则创建新的线程来处理任务。
  - 如果创建线程会使当前运行的线程超过最大线程数，任务将被拒绝，并抛出 RejectedExecutionException 异常。
- 线程执行任务两种情况：
  - 在 execute() 方法创建一个线程时，会让这个线程执行当前任务。
  - 这个线程执行完上述任务后，会反复从工作队列中获取任务来执行。
- 线程池的创建参数：
  - 线程池基本大小 corePoolSize：基本线程数，当提交任务到线程池时，即使其它空闲的线程能够执行，新任务也会创建线程，直至达到线程池基本大小。
  - 任务队列 runnableTaskQueue：用于保存等待执行的任务的阻塞队列。
    - ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO 排序。
    - LinkedBlockingQueue：基于链表的阻塞队列，FIFO 排序，吞吐量高于 ArrayBlockingQueue，newFixedThreadPool() 使用了这个队列。
    - SynchronousQueue：不存储元素的阻塞队列，每个插入需要等到另一个线程调用移除，newCachedThreadPool() 使用了这个队列。
    - PriorityBlockingQueue：具有优先级的无限阻塞队列。
  - 线程池最大数量 maximumPoolSize：线程池允许创建的最大线程数，队列满了并且创建线程数小于最大线程数，会创建新的线程执行任务，如果使用了无界队列则该参数无效果。
  - 线程工厂 threadFactory：设置创建线程的工厂。
  - 饱和策略 rejectedExecutionHandler：默认是 AbortPolicy。
    - AbortPolicy：直接抛出异常。
    - CallerRunsPolicy：直接使用调用者所在线程来运行任务。
    - DiscardOldestPolicy：丢弃队列里最近一个任务，并执行当前任务。
    - DiscardPolicy：不处理，丢弃。
  - 线程活动保持时间 keepAliveTime：如果任务多且每个任务执行时间短，可以调大时间，提高线程利用率。
  - 线程活动保持时间的单位 TimeUnit：可选单位有天、小时、分钟、毫秒、微秒和纳秒。